package com.hedera.services.legacy.client.test;

/*-
 * ‌
 * Hedera Services Test Clients
 * ​
 * Copyright (C) 2018 - 2020 Hedera Hashgraph, LLC
 * ​
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *      http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * ‍
 */

import com.hedera.services.legacy.client.util.RecordFileParser;
import com.hedera.services.legacy.client.util.SSHService;
import com.hederahashgraph.api.proto.java.Transaction;
import com.hederahashgraph.api.proto.java.TransactionBody;
import com.hederahashgraph.api.proto.java.TransactionID;
import com.hederahashgraph.api.proto.java.TransactionRecord;
import com.hederahashgraph.builder.RequestBuilder;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.logging.log4j.Level;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.core.config.Configurator;
import org.junit.Assert;

import java.io.File;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.Comparator;
import java.util.LinkedList;
import java.util.List;


/**
 * Launch multiple test thread, after all threads done, collecting transaction ID and transaction records
 * saved by those test thread. Next, use SSH to retrieve transaction record stream file and event stream file
 * generated by node.
 *
 * Then compare transaction record files with transaction records retrieved from test threads.
 */
public class MixedClient extends ClientBaseThread {

  private static final Logger log = LogManager.getLogger(MixedClient.class);

  private String keyFileName;
  private String userName;
  /**
   * This is the parent thread, it will kick off multiple instances
   * crypto, smart contract file test threads.
   *
   * At the end of submitting transactions, pull events file and records file from node
   * and compare again saved transactionID and transactionRecord
   */
  public MixedClient(String host, int port, long nodeAccountNumber, boolean useSigMap, String [] args, int index) {
    super(host, port, nodeAccountNumber, useSigMap, args, index);
    this.useSigMap = useSigMap;
    this.nodeAccountNumber = nodeAccountNumber;
    this.host = host;
    this.port = port;
    this.userName = args[0];
    this.keyFileName = args[1];
  }

  @Override
  void demo() throws Exception {
    List<ClientBaseThread> threadClients = new LinkedList<>();
    int threadIndex = 0;

    initAccountsAndChannels();

    //instantiate crypto transfer threads
    {
      String [] threadArgs1 = {
              "20",      //amount of operations
              "15",         // TPS
              "5",       // operations between a pair of accounts
              "false"};         // transfer type,
      threadClients.add(new CryptoTransferUpdate(host, port, nodeAccountNumber, useSigMap, threadArgs1, threadIndex++));
    }

    //instantiate crypto update threads
    {
      String [] threadArgs2 = {
              "20",      //amount of operations
              "15",         // TPS
              "5",       // operations between a pair of accounts
              "true"};         // update type
      threadClients.add(new CryptoTransferUpdate(host, port, nodeAccountNumber, useSigMap, threadArgs2, threadIndex++));
    }

    //instantiate smart contract creation threads
    { // 10 2 FETCH_RECORD_COST_ANSWER
      String [] threadArgs = {
              "10",      //amount of operations
              "3",         // TPS
              "FETCH_RECORD_COST_ANSWER"};         // fetch mode
      threadClients.add(new ContractCreate(host, port, nodeAccountNumber, useSigMap, threadArgs, threadIndex++));
    }

    //instantiate smart contract call threads
    { // 10 2 FETCH_RECORD_COST_ANSWER
      String [] threadArgs = {
              "3",      //amount of operations
              "3",         // TPS
              "FETCH_RECEIPT"};         // fetch mode
      threadClients.add(new ContractCall(host, port, nodeAccountNumber, useSigMap, threadArgs, threadIndex++));
    }

    // instantiate file threads
    // TBD
    //

    for(ClientBaseThread thread :threadClients){
      thread.enableBackupTxIDRecord();
    }

    for (ClientBaseThread thread :threadClients) {
      thread.start();
    }
    for (ClientBaseThread thread :threadClients) {
      thread.join();
    }

    // Merge transactionID and transactionRecord from all threads
    for(ClientBaseThread thread :threadClients){
      log.info("Add tx size {}  record size {}", thread.submittedTxID.size(), thread.confirmedTxRecord.size() );
      this.submittedTxID.addAll(thread.submittedTxID);
      this.confirmedTxRecord.addAll(thread.confirmedTxRecord);
    }

    log.info("Expected Transaction ID     amount: {}", submittedTxID.size());
    log.info("Expected Transaction Record amount: {}", confirmedTxRecord.size());
//    for(TransactionID item : submittedTxID){
//      log.info("{}",  printTxID(item));
//    }
//    for(TransactionRecord item : confirmedTxRecord){
//      log.info("Record {}",  item);
//    }

    // sorting transaction ID by valid start timestamp
    Collections.sort(this.submittedTxID, new Comparator<TransactionID>() {
      @Override
      public int compare(TransactionID o1, TransactionID o2) {
        Instant instant1 = RequestBuilder.convertProtoTimeStamp(o1.getTransactionValidStart());
        Instant instant2 = RequestBuilder.convertProtoTimeStamp(o2.getTransactionValidStart());

        if ( instant1.isBefore(instant2)){
          return -1;
        }else if (instant1.isAfter(instant2)){
          return 1;
        }else{
          return 0;
        }
      }
     } );

    // sorting transaction record by consensus timestamp
    Collections.sort(this.confirmedTxRecord, new Comparator<TransactionRecord>() {
      @Override
      public int compare(TransactionRecord o1, TransactionRecord o2) {
        Instant instant1 = RequestBuilder.convertProtoTimeStamp(o1.getConsensusTimestamp());
        Instant instant2 = RequestBuilder.convertProtoTimeStamp(o2.getConsensusTimestamp());

        if ( instant1.isBefore(instant2)){
          return -1;
        }else if (instant1.isAfter(instant2)){
          return 1;
        }else{
          return 0;
        }      }
    } );


    // Init SSH Service
    File keyFile = new File(keyFileName);
    SSHService sshService = new SSHService(userName, host, keyFile);

    // Turn of record parser verbose logging
    Logger logger = LogManager.getLogger("recordStream-log");
    Configurator.setLevel(logger.getName(), Level.ERROR);

    // Fetch record files
    {
      ArrayList<String> extensions = new ArrayList<>();
      extensions.add("*.rcd");
      List<String> rcdFiles = sshService.scpFrom(".", extensions);
      List<TransactionID> txIDFromFile = new LinkedList<>();
      List<TransactionRecord> recordFromList = new LinkedList<>();

      for(String file : rcdFiles){
        Pair<byte[], List<Pair<Transaction, TransactionRecord>>> results = RecordFileParser.loadRecordFile(file);
        List<Pair<Transaction, TransactionRecord>> list = results.getRight();
        for(Pair<Transaction, TransactionRecord> item : list){
          TransactionID txID = TransactionBody.parseFrom(item.getLeft().getBodyBytes())
                  .getTransactionID();
          //log.info("TransactionID {}", txID);
          txIDFromFile.add(txID);
          recordFromList.add(item.getValue());
        }
      }
      log.info("Retrieved number of Transaction ID    : {}", txIDFromFile.size());
      log.info("Retrieved number of Transaction Record: {}", recordFromList.size());
//      for(TransactionID item : txIDFromFile){
//        log.info("{}",  printTxID(item));
//      }


      int missingCount = compareIDList(txIDFromFile, this.submittedTxID);
      if (missingCount != this.submittedTxID.size()){
        log.error("Amount of missed query transaction id does not match submittedTxID size");
        for(TransactionRecord item : recordFromList){
          log.info("--------------------------------------------------");
          log.info("recordFromList = {}",  item);
        }
      }
      Assert.assertEquals(missingCount, this.submittedTxID.size());


      log.info("After adding missing Transaction Record: {}", this.confirmedTxRecord.size());

      boolean recordCompare = compareRecordList(recordFromList, this.confirmedTxRecord);
      Assert.assertTrue(recordCompare);

      //Some record generated by non-free query

    }

    // Fetch events files
    {
//      ArrayList<String> extensions = new ArrayList<>();
//      extensions.add("*.evts");
//      List<String> evtFiles = sshService.scpFrom(".", extensions);
//      for(String file : evtFiles){
//        LoadEventFile.loadEventFile(file);
//      }
    }

    // compare events file, record against submittedTxID and confirmedTxRecord

    //Done
    sshService.close();

    channel.shutdown();

  }


  String printTxID(TransactionID txID){
    return String.valueOf(txID.getAccountID().getAccountNum()) + txID.getTransactionValidStart().toString();
  }

  boolean compareRecordList(List<TransactionRecord> fileList, List<TransactionRecord> queryList) throws Exception {
    boolean result = true;
    if(queryList.size() != fileList.size()){
      log.error("Transaction Record amount does not match file {} vs query {}", fileList.size(),
              queryList.size());
      result = false;
    }
    for(TransactionRecord item : queryList){
      if(!fileList.contains(item)){
        log.error("File result does not have Transaction Record {}", item);
        result = false;
      }
    }
    for(TransactionRecord item : fileList){
      if(!queryList.contains(item)){
        log.error("Query does not have Transaction Record {}", item);
        result = false;
      }
    }
    return result;
  }

  /* return number of missing transaction ID */
  int compareIDList(List<TransactionID> fileList, List<TransactionID> queryList) throws Exception {
    if(queryList.size() != fileList.size()){
      log.error("Transaction ID amount does not match file {} vs query {}", fileList.size(),
              queryList.size());
    }
    for(TransactionID item : queryList){
      if(!fileList.contains(item)){
        log.error("File result does not have Transaction ID {}", item);
        Assert.assertTrue(false);
      }
    }
    int missingCount = 0;
    for(TransactionID item : fileList){
      if(!queryList.contains(item)){
        //log.error("Query does not have Transaction ID {}", item);
        //Missing records belong to transactions of get record query
        TransactionRecord record = getTransactionRecord(genesisAccount, item, false);
        confirmedTxRecord.add(record);
        missingCount++;
      }
    }
    return missingCount;
  }


}
